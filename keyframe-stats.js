#!/usr/bin/env node

const { spawn } = require('child_process');
const ffmpegStatic = require('ffmpeg-static');
const ffprobeStatic = require('ffprobe-static');
const fs = require('fs').promises;
const path = require('path');

class KeyframeStats {
  constructor(inputPath) {
    this.inputPath = inputPath;
  }

  async processPath() {
    const stats = await fs.stat(this.inputPath);
    if (stats.isDirectory()) {
      await this.processDirectory();
    } else {
      await this.processFile(this.inputPath);
    }
  }

  async processDirectory() {
    const files = await fs.readdir(this.inputPath);
    const videoExtensions = ['.mp4', '.avi', '.mkv', '.mov', '.flv', '.wmv'];
    
    for (const file of files) {
      const filePath = path.join(this.inputPath, file);
      const ext = path.extname(filePath).toLowerCase();
      if (videoExtensions.includes(ext)) {
        await this.processFile(filePath);
      }
    }
  }

  async processFile(filePath) {
    const outputFile = this.generateOutputFilename(filePath);
    console.log(`Processing: ${filePath}`);
    
    try {
      const sceneChanges = await this.detectSceneChanges(filePath);
      console.log(`Detected ${sceneChanges.size} scene changes`);

      const result = await this.generateKeyframeStats(filePath, outputFile, sceneChanges);
      console.log(`Stats file generated: ${result.outputFile}`);
      console.log(`Total frames processed: ${result.totalFrames}`);
    } catch (error) {
      console.error(`Failed to process ${filePath}:`, error.message);
    }
  }

  generateOutputFilename(inputFile) {
    const parsedPath = path.parse(inputFile);
    return path.join(parsedPath.dir, `${parsedPath.name}_keyframes.txt`);
  }

  async detectSceneChanges(inputFile) {
    return new Promise((resolve, reject) => {
      const ffmpeg = spawn(ffmpegStatic, [
        '-i', inputFile,
        '-vf', 'select=\'gt(scene,0.3)\',showinfo',
        '-f', 'null',
        '-'
      ]);

      let sceneChanges = new Set();

      ffmpeg.stderr.on('data', (data) => {
        const lines = data.toString().split('\n');
        lines.forEach(line => {
          const match = line.match(/n:(\d+)/);
          if (match) {
            sceneChanges.add(parseInt(match[1]));
          }
        });
      });

      ffmpeg.on('close', (code) => {
        if (code !== 0) {
          reject(new Error(`FFmpeg process exited with code ${code}`));
        } else {
          resolve(sceneChanges);
        }
      });
    });
  }

  async generateKeyframeStats(inputFile, outputFile, sceneChanges) {
    const jsonData = await this.runFFprobe(inputFile);
    const data = JSON.parse(jsonData);
    const stream = data.streams[0];
    const packets = data.packets;

    const width = stream.width;
    const height = stream.height;
    const totalBlocks = Math.floor(width / 16) * Math.floor(height / 16);

    let output = '# XviD 2pass stat file (generated by keyframe-stats)\n';
    output += '# Please do not modify this file\n';

    packets.forEach((packet, index) => {
      const isKeyframe = packet.flags && packet.flags.includes('K');
      const isSceneChange = sceneChanges.has(index);
      const size = parseInt(packet.size) || 0;

      let frameType = (isKeyframe || isSceneChange) ? 'i' : 'p';

      const statLine = `${frameType} 2 ${(isKeyframe || isSceneChange) ? totalBlocks : 0} ${(isKeyframe || isSceneChange) ? 0 : totalBlocks} 0 ${size} ${Math.floor(size / 4)}`;
      output += statLine + '\n';
    });

    await fs.writeFile(outputFile, output);
    return { totalFrames: packets.length, outputFile: outputFile };
  }

  async runFFprobe(inputFile) {
    return new Promise((resolve, reject) => {
      const ffprobe = spawn(ffprobeStatic.path, [
        '-v', 'quiet',
        '-select_streams', 'v:0',
        '-count_packets',
        '-show_entries', 'stream=width,height,r_frame_rate',
        '-show_entries', 'packet=pts_time,dts_time,duration_time,pos,size,flags',
        '-of', 'json',
        inputFile
      ]);

      let jsonData = '';

      ffprobe.stdout.on('data', (data) => {
        jsonData += data.toString();
      });

      ffprobe.on('close', (code) => {
        if (code !== 0) {
          reject(new Error(`FFprobe process exited with code ${code}`));
        } else {
          resolve(jsonData);
        }
      });

      ffprobe.stderr.on('data', (data) => {
        console.error(`FFprobe stderr: ${data}`);
      });
    });
  }
}

// CLI functionality
if (require.main === module) {
  const inputPath = process.argv[2];

  if (!inputPath) {
    console.error('Please provide a video file or folder path as an argument');
    console.error('Usage: keyframe-stats <input_path>');
    process.exit(1);
  }

  const stats = new KeyframeStats(inputPath);
  stats.processPath().catch((error) => {
    console.error('Error:', error.message);
    process.exit(1);
  });
}

module.exports = KeyframeStats;